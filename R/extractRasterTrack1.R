#' @importFrom sp SpatialPointsDataFrame CRS proj4string
#' @importFrom raster extract nlayers
NULL

#' Extracts corresponding raster values for GPS tracks.
#'
#' \code{extractRasterTrack1} extracts values from raster based time series
#' (\code{RasterBrick} or \code{RasterStack} object, see:
#' \code{\link[raster:Raster-classes]{Raster-classes}}) that correspond the the respective
#' position and time of a \code{\link[trajectories:Track-class]{Track}} object with
#' daily resolution.
#'
#' @param currenttrack A \code{\link[trajectories:Track-class]{Track}} object that
#' has a column \code{day} containing the time information of the data
#' values.
#' @param raster raster based time series (\code{RasterBrick} or
#' \code{RasterStack} object, see: \code{\link[raster:Raster-classes]{Raster-classes}}).
#' Eacj layer of \code{raster} has to correspond to a value in
#' \code{currenttrack}, i.e. both must have daily resolution and
#' the same number of values and layers, respectively.
#' @param buffer A numeric value indicating the radius of the buffer
#' around each point that should be considered during extraction of
#' the raster values. If the data are not projected
#' (latitude/longitude), the unit should be meters. Otherwise it should
#' be in map-units (typically also meters).
#' @return A vector with a value for each data value of \code{currenttrack}.
#' If a value of \code{raster} cannot be assigned to a respective data value,
#' \code{NA} is returned for the respective data value.
#' @seealso \code{\link{assignFixedTenDayInterval}},
#' \code{\link{extractRasterTracks}}.
#' @examples #
#' @export
extractRasterTrack1 <- function(currenttrack,
                                raster,
                                buffer = 0) {

  # check if currenttrack is specified correctly
  if(!inherits(currenttrack, "Track")){
    stop("currenttrack must be an object of class Track\n")
  }
  if(!all(c("day", "longitude", "latitude") %in% colnames(currenttrack@data))){
    stop("currenttrack must have columns 'day', 'longitude' and 'latitude'\n")
  }

  # check if raster has the same number of layers as there are values in currenttrack
  if(nrow(currenttrack@data) != raster::nlayers(raster)){
    stop("raster must have the same number of layers as there are values in currenttrack\n")
  }

  # extract the position of each location from currenttrack
  locationsdata <- currenttrack@data[!duplicated(currenttrack@data$location), c(2,3,4)]
  locationsdata <- sp::SpatialPointsDataFrame(coords = locationsdata[,c(2,3)],
                                              data = locationsdata,
                                              proj4string = sp::CRS(sp::proj4string(currenttrack@sp)))

  # extract the location for each day
  eachdaylocation <- currenttrack@data$location

  # define an index for nongaps
  indexnongaps <- which(eachdaylocation != 0)

  # create a vector to store the results in
  res <- rep(NA, length(eachdaylocation))

  # no gaps
  if(nlayers(raster) != 0 && length(indexnongaps) > 0){

    # extract all values from locationsdata and raster that are no gaps
    eachdaylocation <- eachdaylocation[indexnongaps]
    raster <- raster[[indexnongaps]]

    # extract the values for all locations
    extractedvalues <- t(raster::extract(x = raster,
                                         y = locationsdata,
                                         method = "simple",
                                         buffer = buffer,
                                         na.rm = TRUE,
                                         layer = 1,
                                         nl = raster::nlayers(raster),
                                         fun = mean))

    # filter the values for each day for the target location
    extractedvalues <- sapply(seq_along(eachdaylocation), function(x) extractedvalues[x,][which(locationsdata$location == eachdaylocation[x])])

    # insert the values into res
    res[indexnongaps] <- extractedvalues
  }

  # return res
  return(res)

}
