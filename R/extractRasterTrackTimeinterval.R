#' @importFrom sp SpatialPointsDataFrame CRS proj4string
NULL

#' Extracts corresponding raster values for GPS tracks.
#'
#' \code{extractRasterTrackTimeinterval} extracts values from a \code{RasterBrick}
#' or \code{RasterStack} object (see: \code{\link[raster:Raster-classes]{Raster-classes}}) with a
#' temporal resolution greater than one day that corresponds to the respective
#' position of values of a \code{\link[trajectories:Track-class]{Track}} object with
#' daily resolution.
#'
#' @param currenttrack A \code{\link[trajectories:Track-class]{Track}} object that
#' has a column \code{day} containing the time information of the data
#' values.
#' @param raster A \code{RasterBrick} or \code{RasterStack} (see:
#' \code{\link[raster:Raster-classes]{Raster-classes}}). from which values should be
#' extracted. Each layer has to correspond to a time interval with
#' a duration longer than a day.
#' @param timedate A \code{POSIXct} vector with each element representing
#' the first day of the time interval the layers of \code{raster} correspond
#' to plus one element representing the first day after the last day of the
#' last time interval.
#' @param buffer A numeric value indicating the radius of the buffer
#' around each point that should be considered during extraction of
#' the raster values. If the data are not projected
#' (latitude/longitude), the unit should be meters. Otherwise it should
#' be in map-units (typically also meters).
#' @return A vector with a value for each data value of \code{currenttrack}.
#' If a value of \code{raster} cannot be assigned to a respective data value,
#' \code{NA} is returned for the respective data value.
#' @seealso \code{\link{assignFixedTenDayInterval}},
#' \code{\link{extractRasterTracks}}.
#' @examples #
#' @export
extractRasterTrackTimeinterval <- function(currenttrack,
                                           raster,
                                           buffer = 0) {

  # check if currenttrack is specified correctly
  if(!inherits(currenttrack, "Track")){
    stop("currenttrack must be an object of class Track\n")
  }
  if(!all(c("day", "longitude", "latitude") %in% colnames(currenttrack@data))){
    stop("currenttrack must have columns 'day', 'longitude' and 'latitude'\n")
  }

  # extract the position of each location from currenttrack
  locationsdata <- currenttrack@data[!duplicated(currenttrack@data$location), c(2,3,4)]
  locationsdata <- sp::SpatialPointsDataFrame(coords = locationsdata[,c(2,3)],
                                              data = locationsdata,
                                              proj4string = sp::CRS(sp::proj4string(currenttrack@sp)))

  # extract the location for each day
  eachdaylocation <- currenttrack@data$location

  # define an index for nongaps
  indexnongaps <- which(eachdaylocation != 0)

  # create a vector to store the results in
  res <- rep(NA, length(eachdaylocation))

  # extract all values from locationsdata and raster that are no gaps
  eachdaylocation <- eachdaylocation[indexnongaps]

  # extract the values for all locations and layers of raster
  extractedvalues <- lapply(seq_len(nlayers(raster)), function(timeinterval_i){

    # define the time range of the current time interval
    currenttimeinterval <- c(timedate[timeinterval_i], timedate[timeinterval_i+1]-24*60*60)

    # define an index for values in currenttrack fitting to currenttimeinterval
    index <- which(currenttrack$time >= currenttimeinterval[1] & currenttimeinterval <= currenttimeinterval[2])

    # extract the values
    extractedvalues <- do.call(cbind, raster::extract(x = raster[[timeinterval_i]], y = locationsdata, method = "simple", buffer = buffer, na.rm = TRUE))[index,]
  })

  # filter the values for each day for the target location
  extractedvalues <- sapply(seq_along(eachdaylocation), function(x) extractedvalues[which(locationsdata$location == eachdaylocation[x])])

  # insert the values into res
  res[indexnongaps] <- extractedvalues
  res

}
